const fs = require('fs').promises;
const path = require('path');
const readline = require('readline');

async function loadFileList(filename) {
    const filePath = path.join(process.cwd(), filename);
    try {
        const content = await fs.readFile(filePath, 'utf8');
        // Split by newlines, trim whitespace, and filter out empty lines and comments
        return content.split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('#'));
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log(`No ${filename} file found`);
            return [];
        }
        console.error(`Error reading ${filename}:`, error.message);
        return [];
    }
}

async function loadSkipList() {
    return loadFileList('skip.txt');
}

async function loadDeleteList() {
    return loadFileList('delete.txt');
}

async function confirmDeletion(folders) {
    if (folders.length === 0) return false;
    
    console.log('\nWARNING: The following folders will be emptied:');
    folders.forEach(folder => console.log(`- ${folder}`));
    
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    return new Promise(resolve => {
        rl.question('\nAre you sure you want to proceed? (yes/no): ', answer => {
            rl.close();
            resolve(answer.toLowerCase() === 'yes');
        });
    });
}

async function emptyDirectory(dirPath) {
    try {
        const files = await fs.readdir(dirPath);
        for (const file of files) {
            const filePath = path.join(dirPath, file);
            const stats = await fs.lstat(filePath);
            
            if (stats.isSymbolicLink()) {
                await fs.unlink(filePath);
            } else if (stats.isDirectory()) {
                await emptyDirectory(filePath);
                await fs.rmdir(filePath);
            } else {
                await fs.unlink(filePath);
            }
        }
    } catch (error) {
        console.error(`Error emptying directory ${dirPath}:`, error.message);
    }
}

async function getDirectorySize(dirPath) {
    let totalSize = 0;
    
    try {
        const files = await fs.readdir(dirPath);
        
        for (const file of files) {
            const filePath = path.join(dirPath, file);
            const stats = await fs.lstat(filePath); // Using lstat instead of stat to not follow symlinks
            
            if (stats.isSymbolicLink()) {
                continue; // Skip symlinks
            }
            
            if (stats.isDirectory()) {
                totalSize += await getDirectorySize(filePath);
            } else {
                totalSize += stats.size;
            }
        }
        
        return totalSize;
    } catch (error) {
        console.error(`Error reading directory ${dirPath}: ${error.message}`);
        return 0;
    }
}

async function findNodeModules(startPath, skipList) {
    let nodeModulesPaths = [];
    
    try {
        const files = await fs.readdir(startPath);
        
        // Check if this directory should be skipped
        const normalizedPath = path.normalize(startPath);
        if (skipList.some(skipPath => normalizedPath.includes(path.normalize(skipPath)))) {
            console.log(`Skipping directory (in skip list): ${startPath}`);
            return [];
        }
        
        for (const file of files) {
            if (file.startsWith('.')) continue; // Skip hidden directories
            
            const filePath = path.join(startPath, file);
            try {
                const stats = await fs.lstat(filePath); // Using lstat instead of stat to not follow symlinks
                
                if (stats.isSymbolicLink()) {
                    continue; // Skip symlinks
                }
                
                if (stats.isDirectory()) {
                    if (file === 'node_modules') {
                        nodeModulesPaths.push(filePath);
                    } else {
                        // Recursively search subdirectories
                        const subDirPaths = await findNodeModules(filePath, skipList);
                        nodeModulesPaths = nodeModulesPaths.concat(subDirPaths);
                    }
                }
            } catch (error) {
                console.error(`Error accessing ${filePath}: ${error.message}`);
            }
        }
    } catch (error) {
        console.error(`Error reading directory ${startPath}: ${error.message}`);
    }
    
    return nodeModulesPaths;
}

async function formatSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let size = bytes;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }
    
    return `${size.toFixed(2)} ${units[unitIndex]}`;
}

async function main() {
    // Check for --delete flag and remove it from args if present
    const args = process.argv.slice(2);
    const deleteFlag = args.includes('--delete');
    const paths = args.filter(arg => arg !== '--delete');

    const skipList = await loadSkipList();
    const deleteList = await loadDeleteList();
    
    if (skipList.length > 0) {
        console.log('Loaded skip list with the following paths:');
        skipList.forEach(path => console.log(`- ${path}`));
        console.log();
    }

    if (deleteList.length > 0) {
        console.log('Loaded delete list with the following paths:');
        deleteList.forEach(path => console.log(`- ${path}`));
        console.log();
    }
    
    if (paths.length === 0) {
        paths.push(process.cwd());
    }
    
    console.log('Searching for node_modules directories in:');
    paths.forEach(path => console.log(`- ${path}`));
    
    let allNodeModulesPaths = [];
    for (const startPath of paths) {
        try {
            const nodeModulesPaths = await findNodeModules(startPath, skipList);
            allNodeModulesPaths = allNodeModulesPaths.concat(nodeModulesPaths);
        } catch (error) {
            console.error(`Error searching in ${startPath}: ${error.message}`);
        }
    }
    
    // Remove duplicates in case of overlapping paths
    allNodeModulesPaths = [...new Set(allNodeModulesPaths)];
    let totalSize = 0;
    
    console.log('\nFound node_modules directories:');
    for (const dirPath of allNodeModulesPaths) {
        const size = await getDirectorySize(dirPath);
        totalSize += size;
        console.log(`${dirPath}: ${await formatSize(size)}`);
    }
    
    console.log(`\nTotal size of all node_modules: ${await formatSize(totalSize)}`);
    console.log(`Number of node_modules directories found: ${allNodeModulesPaths.length}`);

    // Handle deletion only if --delete flag is present
    if (deleteList.length > 0 && deleteFlag) {
        const foldersToDelete = allNodeModulesPaths.filter(dirPath => {
            const normalizedPath = path.normalize(dirPath);
            return deleteList.some(deletePath => 
                normalizedPath.includes(path.normalize(deletePath))) &&
                !skipList.some(skipPath => 
                    normalizedPath.includes(path.normalize(skipPath)));
        });

        if (foldersToDelete.length > 0) {
            const confirmed = await confirmDeletion(foldersToDelete);
            if (confirmed) {
                console.log('\nEmptying directories...');
                let totalFreed = 0;
                
                for (const dirPath of foldersToDelete) {
                    const sizeBeforeDelete = await getDirectorySize(dirPath);
                    await emptyDirectory(dirPath);
                    console.log(`Freed up ${await formatSize(sizeBeforeDelete)} from ${dirPath}`);
                    totalFreed += sizeBeforeDelete;
                }
                
                console.log(`\nTotal space freed: ${await formatSize(totalFreed)}`);
                console.log('Finished emptying directories');
            } else {
                console.log('Deletion cancelled');
            }
        } else {
            console.log('\nNo directories matched the delete list (or all matched directories were in skip list)');
        }
    } else if (deleteList.length > 0 && !deleteFlag) {
        console.log('\nNote: delete.txt found but --delete flag not provided. Run with --delete to empty directories.');
    }
}

main().catch(error => {
    console.error('An error occurred:', error);
    process.exit(1);
});